<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LCode: Sugestões de Melhorias para a Biblioteca DisplayFK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="iconmain.png"/></td>
  <td id="projectalign">
   <div id="projectname">LCode
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Sugestões de Melhorias para a Biblioteca <a class="el" href="class_display_f_k.html" title="Represents the main display framework class, managing various widget types, SD card functionality,...">DisplayFK</a> </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Após analisar detalhadamente a biblioteca <a class="el" href="class_display_f_k.html" title="Represents the main display framework class, managing various widget types, SD card functionality,...">DisplayFK</a>, identifiquei diversas oportunidades de melhoria em termos de desempenho, consumo de memória, facilidade de uso e otimização de redesenho. A seguir, apresento propostas organizadas por áreas:</p>
<h1><a class="anchor" id="autotoc_md26"></a>
1. Arquitetura e Design</h1>
<h2><a class="anchor" id="autotoc_md27"></a>
1.1. Memória e Alocação</h2>
<ul>
<li><b>Implementar gerenciamento de memória por pool</b>: Substituir a alocação dinâmica individual por um sistema de pool de memória pré-alocado, reduzindo a fragmentação de heap.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Exemplo de implementação de pool de widgets</span></div>
<div class="line"><span class="keyword">class </span>WidgetPool {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> MAX_WIDGETS = 50;</div>
<div class="line">    uint8_t used = 0;</div>
<div class="line">    <a class="code hl_class" href="class_widget_base.html">WidgetBase</a>* widgets[MAX_WIDGETS];</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    T* create(Args&amp;&amp;... args) {</div>
<div class="line">        <span class="keywordflow">if</span> (used &gt;= MAX_WIDGETS) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">        T* widget = <span class="keyword">new</span> T(std::forward&lt;Args&gt;(args)...);</div>
<div class="line">        widgets[used++] = widget;</div>
<div class="line">        <span class="keywordflow">return</span> widget;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> release() {</div>
<div class="line">        <span class="keywordflow">for</span> (uint8_t i = 0; i &lt; used; i++) {</div>
<div class="line">            <span class="keyword">delete</span> widgets[i];</div>
<div class="line">        }</div>
<div class="line">        used = 0;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclass_widget_base_html"><div class="ttname"><a href="class_widget_base.html">WidgetBase</a></div><div class="ttdoc">Base class for all widgets.</div><div class="ttdef"><b>Definition:</b> widgetbase.h:58</div></div>
</div><!-- fragment --><ul>
<li><b>Uso de buffer estático para redraw</b>: Implementar um buffer intermediário dedicado para widgets que exigem redesenho frequente como <a class="el" href="class_line_chart.html" title="Represents a line chart widget for plotting data with optional secondary line.">LineChart</a> e Gauge.</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
1.2. Desenho e Renderização</h2>
<ul>
<li><b>Sistema de Dirty Regions</b>: Implementar um sistema que rastreie regiões da tela que precisam ser atualizadas, evitando redesenhos completos.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">struct </span>DirtyRegion {</div>
<div class="line">    uint16_t x, y, width, height;</div>
<div class="line">    <span class="keywordtype">bool</span> needsUpdate;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// No método de atualização da tela</span></div>
<div class="line"><span class="keywordtype">void</span> updateScreen() {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; region : dirtyRegions) {</div>
<div class="line">        <span class="keywordflow">if</span> (region.needsUpdate) {</div>
<div class="line">            updateRegion(region.x, region.y, region.width, region.height);</div>
<div class="line">            region.needsUpdate = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Renderização em camadas</b>: Implementar um sistema de camadas (layers) para otimizar o redesenho apenas das camadas que mudaram.</li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
1.3. Arquitetura de Widgets</h2>
<ul>
<li><b>Uso de templates para reduzir código duplicado</b>: Aplicar templates em C++ para evitar repetição em widgets com comportamentos similares.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType&gt;</div>
<div class="line"><span class="keyword">class </span>ValueWidget : <span class="keyword">public</span> <a class="code hl_class" href="class_widget_base.html">WidgetBase</a> {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    ValueType m_value;</div>
<div class="line">    ValueType m_min, m_max;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setValue(ValueType value) {</div>
<div class="line">        <span class="keywordflow">if</span> (value != m_value) {</div>
<div class="line">            m_value = value;</div>
<div class="line">            forceUpdate();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ValueType getValue()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_value; }</div>
<div class="line">    <span class="keywordtype">void</span> setRange(ValueType min, ValueType max) {</div>
<div class="line">        m_min = min;</div>
<div class="line">        m_max = max;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implementação especializada</span></div>
<div class="line"><span class="keyword">class </span>Slider : <span class="keyword">public</span> ValueWidget&lt;int&gt; {</div>
<div class="line">    <span class="comment">// Implementação específica de Slider</span></div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md30"></a>
2. Otimizações de Performance</h1>
<h2><a class="anchor" id="autotoc_md31"></a>
2.1. Redução do Tempo de Renderização</h2>
<ul>
<li><b>Minimizar chamadas à SPI/I2C</b>: Agrupar operações de comunicação com o display para reduzir sobrecarga de protocolo.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Em vez de múltiplas chamadas SPI para cada pixel</span></div>
<div class="line"><span class="keywordtype">void</span> drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) {</div>
<div class="line">    <span class="comment">// Configurar a área de escrita de uma vez</span></div>
<div class="line">    tft-&gt;setAddrWindow(x, y, w, 1);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Enviar todos os pixels de uma só vez</span></div>
<div class="line">    uint16_t colorBuffer[w];</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; w; i++) colorBuffer[i] = color;</div>
<div class="line">    tft-&gt;startWrite();</div>
<div class="line">    tft-&gt;writePixels(colorBuffer, w);</div>
<div class="line">    tft-&gt;endWrite();</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Desenho diferencial</b>: Implementar um sistema que só redesenha as partes dos widgets que realmente mudaram.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Para gráficos de linha</span></div>
<div class="line"><span class="keywordtype">void</span> updateLineChart() {</div>
<div class="line">    <span class="comment">// Apenas redesenhar os últimos pontos adicionados</span></div>
<div class="line">    <span class="keywordflow">if</span> (newPointsAdded) {</div>
<div class="line">        <span class="keywordtype">int</span> startX = lastDrawnPoint;</div>
<div class="line">        drawPartialChart(startX, chartWidth);</div>
<div class="line">        lastDrawnPoint = currentPosition;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
2.2. Otimização para FreeRTOS</h2>
<ul>
<li><b>Uso eficiente de tarefas</b>: Reorganizar o sistema de tarefas para minimizar o consumo de memória e melhorar a responsividade.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Definir prioridades adequadas</span></div>
<div class="line"><span class="preprocessor">#define TOUCH_TASK_PRIORITY 3</span></div>
<div class="line"><span class="preprocessor">#define RENDER_TASK_PRIORITY 2</span></div>
<div class="line"><span class="preprocessor">#define UPDATE_TASK_PRIORITY 1</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Criar uma tarefa específica para renderização</span></div>
<div class="line"><span class="keywordtype">void</span> createRenderTask() {</div>
<div class="line">    xTaskCreatePinnedToCore(</div>
<div class="line">        renderTaskFunction,</div>
<div class="line">        <span class="stringliteral">&quot;RenderTask&quot;</span>,</div>
<div class="line">        4096,  <span class="comment">// Tamanho de stack otimizado</span></div>
<div class="line">        NULL,</div>
<div class="line">        RENDER_TASK_PRIORITY,</div>
<div class="line">        &amp;renderTaskHandle,</div>
<div class="line">        0  <span class="comment">// Executar no core 0 (APP core)</span></div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Semáforos e mutexes otimizados</b>: Implementar um sistema de semáforos mais eficiente para proteger recursos compartilhados.</li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
2.3. Aceleração Gráfica</h2>
<ul>
<li><b>Uso de funções DMA</b>: Para displays que suportam, implementar transferência DMA para operações gráficas intensivas.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Exemplo para ESP32</span></div>
<div class="line"><span class="keywordtype">void</span> transferDMA(uint16_t* buffer, <span class="keywordtype">size_t</span> size) {</div>
<div class="line">    spi_transaction_t t;</div>
<div class="line">    memset(&amp;t, 0, <span class="keyword">sizeof</span>(t));</div>
<div class="line">    t.length = size * 16; <span class="comment">// bits</span></div>
<div class="line">    t.tx_buffer = buffer;</div>
<div class="line">    t.user = (<span class="keywordtype">void</span>*)1; <span class="comment">// Flag para configurar DC pin</span></div>
<div class="line">    spi_device_transmit(spi, &amp;t);</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Implementar compressão de dados</b>: Para imagens e ícones, usar formatos comprimidos ou RLE (Run-Length Encoding).</li>
</ul>
<h1><a class="anchor" id="autotoc_md34"></a>
3. Facilidade de Uso</h1>
<h2><a class="anchor" id="autotoc_md35"></a>
3.1. API Fluente</h2>
<ul>
<li><b>Implementar interface fluente (método encadeado)</b>: Tornar a configuração de widgets mais concisa e legível.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Em vez de múltiplas chamadas de setup</span></div>
<div class="line">Button* createButton(uint16_t x, uint16_t y) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> Button(x, y, 0)</div>
<div class="line">        .setSize(80, 40)</div>
<div class="line">        .setColors(BLUE, DARK_BLUE, WHITE)</div>
<div class="line">        .setRoundRadius(5)</div>
<div class="line">        .setText(<span class="stringliteral">&quot;OK&quot;</span>)</div>
<div class="line">        .setCallback(buttonCallback);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36"></a>
3.2. Sistema de Eventos Melhorado</h2>
<ul>
<li><b>Implementar sistema de eventos baseado em delegados</b>: Substituir callbacks simples por um sistema de eventos mais flexível.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Definição do sistema de eventos</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">class </span>Event {</div>
<div class="line">    std::vector&lt;std::function&lt;void(Args...)&gt;&gt; handlers;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> subscribe(std::function&lt;<span class="keywordtype">void</span>(Args...)&gt; handler) {</div>
<div class="line">        handlers.push_back(handler);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> operator()(Args... args) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; handler : handlers) {</div>
<div class="line">            handler(args...);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Uso em um botão</span></div>
<div class="line"><span class="keyword">class </span>Button : <span class="keyword">public</span> <a class="code hl_class" href="class_widget_base.html">WidgetBase</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Event&lt;Button*&gt; onClick;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> touch() {</div>
<div class="line">        <span class="comment">// Acionar o evento com this como parâmetro</span></div>
<div class="line">        onClick(<span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Uso pelo cliente</span></div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">    Button* btn = <span class="keyword">new</span> Button(10, 10, 0);</div>
<div class="line">    btn-&gt;onClick.subscribe([](Button* sender) {</div>
<div class="line">        Serial.println(<span class="stringliteral">&quot;Botão pressionado!&quot;</span>);</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
3.3. Documentação e Exemplos</h2>
<ul>
<li><b>Melhorar a documentação com exemplos mais intuitivos</b>: Criar exemplos modulares que demonstrem funcionalidades específicas.</li>
</ul>
<h1><a class="anchor" id="autotoc_md38"></a>
4. Economia de Memória</h1>
<h2><a class="anchor" id="autotoc_md39"></a>
4.1. Redução de Footprint</h2>
<ul>
<li><b>Compilação condicional mais granular</b>: Permitir inclusão seletiva de apenas os widgets necessários.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Em um arquivo de configuração</span></div>
<div class="line"><span class="preprocessor">#define USE_BUTTON 1</span></div>
<div class="line"><span class="preprocessor">#define USE_SLIDER 1</span></div>
<div class="line"><span class="preprocessor">#define USE_CHART 0  </span><span class="comment">// Desabilitar se não for usado</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Na implementação</span></div>
<div class="line"><span class="preprocessor">#if USE_BUTTON</span></div>
<div class="line"><span class="keyword">class </span>Button {...};</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><ul>
<li><b>Uso de bitfields</b>: Reduzir o tamanho de estruturas usando bitfields para flags e estados.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">struct </span>WidgetState {</div>
<div class="line">    uint8_t visible : 1;</div>
<div class="line">    uint8_t enabled : 1;</div>
<div class="line">    uint8_t focused : 1;</div>
<div class="line">    uint8_t pressed : 1;</div>
<div class="line">    uint8_t needsRedraw : 1;</div>
<div class="line">    uint8_t reserve : 3;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md40"></a>
4.2. Compartilhamento de Recursos</h2>
<ul>
<li><b>Sistema de gerenciamento de recursos</b>: Implementar um sistema para compartilhar recursos como fontes e cores entre widgets.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>ResourceManager {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> GFXfont* sharedFonts[5];  <span class="comment">// Array de fontes compartilhadas</span></div>
<div class="line">    <span class="keyword">static</span> uint16_t commonColors[10]; <span class="comment">// Cores comuns usadas na interface</span></div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> GFXfont* getFont(uint8_t fontId) { <span class="keywordflow">return</span> sharedFonts[fontId]; }</div>
<div class="line">    <span class="keyword">static</span> uint16_t getColor(uint8_t colorId) { <span class="keywordflow">return</span> commonColors[colorId]; }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md41"></a>
5. Exemplos de Melhorias Específicas por Widget</h1>
<h2><a class="anchor" id="autotoc_md42"></a>
5.1. LineChart</h2>
<ul>
<li><b>Otimização de redesenho parcial</b>: Implementar um sistema que apenas redesenha a parte do gráfico que mudou.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_line_chart.html#ac36b2ea9ad6140ae807b4baec38aa16f">LineChart::push</a>(uint16_t serieIndex, <span class="keywordtype">int</span> newValue) {</div>
<div class="line">    <span class="comment">// Armazenar posição anterior para limpar</span></div>
<div class="line">    <span class="keywordtype">int</span> oldEndX = m_endX;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Adicionar novo valor</span></div>
<div class="line">    m_values[serieIndex][m_currentIndex] = newValue;</div>
<div class="line">    m_currentIndex = (m_currentIndex + 1) % m_maxAmountValues;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Calcular nova posição final</span></div>
<div class="line">    m_endX = m_leftPadding + m_currentIndex * m_spaceBetweenPoints;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Redesenhar apenas a parte que mudou</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_endX &gt; oldEndX) {</div>
<div class="line">        drawPartialChart(oldEndX, m_endX);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_endX &lt; oldEndX) {</div>
<div class="line">        <span class="comment">// Wrap-around, limpar tudo e redesenhar</span></div>
<div class="line">        <a class="code hl_function" href="class_line_chart.html#a436cac351397d813da3c7350788a2b8e">redraw</a>();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_line_chart_html_a436cac351397d813da3c7350788a2b8e"><div class="ttname"><a href="class_line_chart.html#a436cac351397d813da3c7350788a2b8e">LineChart::redraw</a></div><div class="ttdeci">void redraw()</div><div class="ttdoc">Redraws the entire LineChart.</div><div class="ttdef"><b>Definition:</b> wlinechart.cpp:450</div></div>
<div class="ttc" id="aclass_line_chart_html_ac36b2ea9ad6140ae807b4baec38aa16f"><div class="ttname"><a href="class_line_chart.html#ac36b2ea9ad6140ae807b4baec38aa16f">LineChart::push</a></div><div class="ttdeci">bool push(uint16_t serieIndex, int newValue)</div><div class="ttdoc">Adds a new value to the specified series of the chart.</div><div class="ttdef"><b>Definition:</b> wlinechart.cpp:263</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md43"></a>
5.2. Gauge e Indicadores Circulares</h2>
<ul>
<li><b>Cache de transformações trigonométricas</b>: Pré-calcular valores de seno e cosseno para ângulos comuns.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_gauge_super.html">GaugeSuper</a> : <span class="keyword">public</span> <a class="code hl_class" href="class_widget_base.html">WidgetBase</a> {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Cache de transformações trigonométricas para ângulos comuns</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">int</span> ANGLE_STEPS = 360; <span class="comment">// 1 grau de resolução</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">float</span> sinCache[ANGLE_STEPS];</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">float</span> cosCache[ANGLE_STEPS];</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> cacheInitialized;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> initTrigCache() {</div>
<div class="line">        <span class="keywordflow">if</span> (!cacheInitialized) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ANGLE_STEPS; i++) {</div>
<div class="line">                <span class="keywordtype">float</span> angle = i * DEG_TO_RAD;</div>
<div class="line">                sinCache[i] = sin(angle);</div>
<div class="line">                cosCache[i] = cos(angle);</div>
<div class="line">            }</div>
<div class="line">            cacheInitialized = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Usar o cache em vez de calcular sin/cos em tempo real</span></div>
<div class="line">    <span class="keywordtype">void</span> drawNeedle(<span class="keywordtype">float</span> angle) {</div>
<div class="line">        <span class="keywordtype">int</span> angleIndex = ((int)angle) % ANGLE_STEPS;</div>
<div class="line">        <span class="keywordtype">float</span> s = sinCache[angleIndex];</div>
<div class="line">        <span class="keywordtype">float</span> c = cosCache[angleIndex];</div>
<div class="line">        <span class="comment">// Desenhar usando valores pré-calculados</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclass_gauge_super_html"><div class="ttname"><a href="class_gauge_super.html">GaugeSuper</a></div><div class="ttdoc">Represents a gauge widget with a needle and color-coded intervals.</div><div class="ttdef"><b>Definition:</b> wgaugesuper.h:28</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md44"></a>
6. Conclusão</h1>
<p>A biblioteca <a class="el" href="class_display_f_k.html" title="Represents the main display framework class, managing various widget types, SD card functionality,...">DisplayFK</a> é bastante completa e versátil, mas pode se beneficiar significativamente destas melhorias propostas. As otimizações de memória e redesenho trarão ganhos significativos especialmente em dispositivos com recursos limitados como o ESP32, enquanto as melhorias na API aumentarão a produtividade dos desenvolvedores.</p>
<p>A implementação destas sugestões deve ser priorizada com base no impacto esperado e na facilidade de integração, sendo as melhorias de gerenciamento de memória e otimização de redesenho as mais críticas para o desempenho geral. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
